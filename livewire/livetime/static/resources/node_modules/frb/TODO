
-   filter binder:
        filteredValues <- values.filter{predicate}
            projecting each value in values:
                if predicate becomes true, add predicate to filteredValues in its relative position
                if predicate becomes false, remove predicate from filteredValues in its relative position
        values.filter{predicate} <- filteredValues
            projecting each value in filteredValues
            values.enumerate() produces [index, value] pairs
            values.enumerate().map{[.0, .1, .1|predicate]}
                (value) predicate <- filteredValues.has(value) (at respective position)
                    filteredValues[indexRef.index] == value
        [value, predicateValue, valueIndex, filterIndex]
            observing value
            observing predicateValue

        observeValues
            map [value, predicateValue, valueIndex, filterIndex]
            produce initial presumed filteredValues
            observeFilteredValues

-   map binder:
        mappedValues <- values.map{relation}
            projecting each value in values:
        values.map{relation} <- mappedValues
            projecting each value in mappedValues
                bind (value) relation <- mappedValue
            each time a value is removed
                cancel the binding
            each time a value is added
                no source value exists, so creating one is a bit problematic.
                perhaps fill the void with a undefined and skip the binding

-   lexical scoping in blocks

